///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.10.3.10338/W32 for 8051        27/Feb/2012  22:31:08 /
// Copyright 2004-2011 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  near                                              /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data                                              /
//    Dptr setup         =  2,separate,16,inc                                 /
//    Source file        =  C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Compone /
//                          nts\simpliciti\nwk\nwk_api.c                      /
//    Command line       =  -f "C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Pro /
//                          jects\Examples\SRF04\UART_Bridge\IAR\Configuratio /
//                          n\LinkTo\smpl_config.dat" (-DNUM_CONNECTIONS=2    /
//                          -DSIZE_INFRAME_Q=2 -DSIZE_OUTFRAME_Q=2            /
//                          -DTHIS_DEVICE_ADDRESS={0x1} -DEND_DEVICE          /
//                          -DLINK_TO -DxNWK_PLL_REFERENCE_CLOCK) -f          /
//                          "C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Projec /
//                          ts\Examples\SRF04\UART_Bridge\IAR\Configuration\s /
//                          mpl_nwk_config.dat" (-DMAX_HOPS=3                 /
//                          -DMAX_HOPS_FROM_ME=3 -DCOMMAND_SIZE=10            /
//                          -DLOGTEMP_SIZE=100 -DMAX_HOPS_FROM_AP=1           /
//                          -DMAX_NWK_PAYLOAD=34 -DMAX_APP_PAYLOAD=20         /
//                          -DDEFAULT_LINK_TOKEN=0x01020304                   /
//                          -DDEFAULT_JOIN_TOKEN=0x05060708                   /
//                          -DxFREQUENCY_AGILITY -DxAPP_AUTO_ACK              /
//                          -DEXTENDED_API -DxSMPL_SECURE                     /
//                          -DxNVOBJECT_SUPPORT -DxSW_TIMER                   /
//                          -DxFREQUENCY_HOPPING -DBSP_TIMER_USED=1           /
//                          -DNWK_PLL_SHOW_LOCATION_INDICATORS                /
//                          -DUART_NUMBER=UART_NUMBER_0                       /
//                          -DUART_LOCATION=UART_LOCATION_1                   /
//                          -DUART_BAUD_RATE=9600 -DUART_FLOW_CONTROL=UART_FL /
//                          OW_CONTROL_OFF -DUART_PARITY_MODE=UART_PARITY_NON /
//                          E -DUART_STOP_BITS=UART_1_STOP_BIT) "C:\Texas     /
//                          Instruments\SimpliciTI-IAR-1.2.0\Components\simpl /
//                          iciti\nwk\nwk_api.c" -D "MCU_H=\"ioCC1110.h\""    /
//                          -D MRFI_CC1110 -lB "C:\Texas                      /
//                          Instruments\SimpliciTI-IAR-1.2.0\Projects\Example /
//                          s\SRF04\UART_Bridge\IAR\CC1110-LinkTo\List\" -o   /
//                          "C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Projec /
//                          ts\Examples\SRF04\UART_Bridge\IAR\CC1110-LinkTo\O /
//                          bj\" -e --debug --core=plain                      /
//                          --dptr=16,2,separate,inc --data_model=large       /
//                          --code_model=near --calling_convention=xdata_reen /
//                          trant --place_constants=data --nr_virtual_regs 8  /
//                          -I "C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Pro /
//                          jects\Examples\SRF04\UART_Bridge\IAR\..\..\..\..\ /
//                          ..\Components\bsp\" -I "C:\Texas                  /
//                          Instruments\SimpliciTI-IAR-1.2.0\Projects\Example /
//                          s\SRF04\UART_Bridge\IAR\..\..\..\..\..\Components /
//                          \bsp\drivers\" -I "C:\Texas                       /
//                          Instruments\SimpliciTI-IAR-1.2.0\Projects\Example /
//                          s\SRF04\UART_Bridge\IAR\..\..\..\..\..\Components /
//                          \bsp\boards\SRF04EB\" -I "C:\Texas                /
//                          Instruments\SimpliciTI-IAR-1.2.0\Projects\Example /
//                          s\SRF04\UART_Bridge\IAR\..\..\..\..\..\Components /
//                          \mrfi\" -I "C:\Texas Instruments\SimpliciTI-IAR-1 /
//                          .2.0\Projects\Examples\SRF04\UART_Bridge\IAR\..\. /
//                          .\..\..\..\Components\SimpliciTI\nwk\" -I         /
//                          "C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Projec /
//                          ts\Examples\SRF04\UART_Bridge\IAR\..\..\..\..\..\ /
//                          Components\SimpliciTI\nwk_applications\" -I       /
//                          "C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Projec /
//                          ts\Examples\SRF04\UART_Bridge\IAR\..\..\..\..\..\ /
//                          Components\ApplicationFramwork\" -Ohs             /
//    List file          =  C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Project /
//                          s\Examples\SRF04\UART_Bridge\IAR\CC1110-LinkTo\Li /
//                          st\nwk_api.s51                                    /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME nwk_api

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?ADD_XSTACK_DISP0_8
        EXTERN ?ALLOC_XSTACK8
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?DPH1
        EXTERN ?DPL1
        EXTERN ?DPS
        EXTERN ?FUNC_ENTER_XDATA
        EXTERN ?FUNC_LEAVE_XDATA
        EXTERN ?PUSH_XSTACK8_X_2DPTR
        EXTERN ?PUSH_XSTACK_I_TWO
        EXTERN ?V0
        EXTERN ?XLOAD_R2345
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8
        EXTERN ?XSTACK_RESTORE_DPTRS_1
        EXTERN ?XSTACK_SAVE_DPTRS_1
        EXTERN __INIT_XDATA_Z

        PUBLIC SMPL_Commission
        PUBLIC SMPL_Init
        PUBLIC SMPL_Ioctl
        PUBLIC SMPL_Link
        PUBLIC SMPL_LinkListen
        PUBLIC SMPL_Ping
        PUBLIC SMPL_Receive
        PUBLIC SMPL_Send
        PUBLIC SMPL_SendOpt
        PUBLIC SMPL_Unlink

        EXTERN MRFI_Init
        EXTERN nwk_nwkInit
        EXTERN MRFI_WakeUp
        EXTERN nwk_getMyAddress
        EXTERN MRFI_SetRxAddrFilter
        EXTERN MRFI_EnableRxAddrFilter
        EXTERN nwk_join
        EXTERN MRFI_GetRadioState
        EXTERN nwk_setListenContext
        EXTERN MRFI_RxOn
        EXTERN nwk_getLocalLinkID
        EXTERN MRFI_DelayMs
        EXTERN MRFI_Sleep
        EXTERN MRFI_RxIdle
        EXTERN nwk_getConnInfo
        EXTERN nwk_checkConnInfo
        EXTERN nwk_buildFrame
        EXTERN memcpy
        EXTERN nwk_sendFrame
        EXTERN nwk_retrieveFrame
        EXTERN nwk_link
        EXTERN nwk_unlink
        EXTERN nwk_ping
        EXTERN nwk_getNextConnection
        EXTERN nwk_freeConnection
        EXTERN nwk_setLinkToken
        EXTERN nwk_getLinkToken
        EXTERN nwk_setJoinToken
        EXTERN nwk_getJoinToken
        EXTERN nwk_NVObj
        EXTERN nwk_connectionControl
        EXTERN nwk_deviceAddress
        EXTERN nwk_rawSend
        EXTERN nwk_rawReceive
        EXTERN nwk_radioControl
        EXTERN nwk_getFWVersion
        EXTERN nwk_getProtocolVersion

// C:\Texas Instruments\SimpliciTI-IAR-1.2.0\Components\simpliciti\nwk\nwk_api.c
//    1 /**************************************************************************************************
//    2   Filename:       nwk_api.c
//    3   Revised:        $Date: 2011-10-26 15:44:58 -0700 (Wed, 26 Oct 2011) $
//    4   Revision:       $Revision: 28059 $
//    5   Author:         $Author: jnoxon $
//    6 
//    7   Description:    This file supports the SimpliciTI appliction layer API.
//    8 
//    9   Copyright 2007-2009 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights granted under
//   12   the terms of a software license agreement between the user who downloaded the software,
//   13   his/her employer (which must be your employer) and Texas Instruments Incorporated (the
//   14   "License"). You may not use this Software unless you agree to abide by the terms of the
//   15   License. The License limits your use, and you acknowledge, that the Software may not be
//   16   modified, copied or distributed unless embedded on a Texas Instruments microcontroller
//   17   or used solely and exclusively in conjunction with a Texas Instruments radio frequency
//   18   transceiver, which is integrated into your product. Other than for the foregoing purpose,
//   19   you may not use, reproduce, copy, prepare derivative works of, modify, distribute,
//   20   perform, display or sell this Software and/or its documentation for any purpose.
//   21 
//   22   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS?  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY
//   23   WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
//   24   IN NO EVENT SHALL TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   25   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE
//   26   THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY
//   27   INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST
//   28   DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY
//   29   THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   30 
//   31   Should you have any questions regarding your right to use this Software,
//   32   contact Texas Instruments Incorporated at www.TI.com.
//   33 **************************************************************************************************/
//   34 
//   35 /******************************************************************************
//   36  * INCLUDES
//   37  */
//   38 
//   39 #include <string.h>
//   40 #include "bsp.h"  
//   41 #include "mrfi.h"
//   42 #include "nwk_types.h"
//   43 #include "nwk_api.h"
//   44 #include "nwk_frame.h"
//   45 #include "nwk.h"
//   46 #include "nwk_app.h"
//   47 #include "mrfi.h"
//   48 #include "nwk_globals.h"
//   49 #include "nwk_freq.h"
//   50 #include "nwk_pll.h"
//   51 #ifdef DEBUG_CRITICAL_SECTIONS
//   52   #include "bsp_leds.h"
//   53 #endif
//   54 
//   55 /******************************************************************************
//   56  * MACROS
//   57  */
//   58 
//   59 /******************************************************************************
//   60  * CONSTANTS AND DEFINES
//   61  */
//   62 
//   63 /* These defines are in support an application listening for a link frame to
//   64  * terminate after some amount of time. The intention is that this guard be
//   65  * the exception. The intention of the SimpliciTI design is that the
//   66  * temporal contiguity between the listen and the reception of the link frame
//   67  * from the peer be very tight. The SMPL_LinkListen() should be termninated
//   68  * by the reception of the link frame. But in case it does not receive the frame
//   69  * the support below allows intervention by the application.
//   70  */
//   71 
//   72 /* The intention is for user to modify just the following single value */
//   73 #define LINKLISTEN_MILLISECONDS_2_WAIT    (5000)
//   74 //#define LINKLISTEN_MILLISECONDS_2_WAIT    (500)
//   75 
//   76 #define LINKLISTEN_POLL_PERIOD_MS         (10)
//   77 #define LINKLISTEN_POLL_COUNT             ( (LINKLISTEN_MILLISECONDS_2_WAIT) / (LINKLISTEN_POLL_PERIOD_MS) )
//   78 
//   79 /******************************************************************************
//   80  * TYPEDEFS
//   81  */
//   82 
//   83 /******************************************************************************
//   84  * LOCAL VARIABLES
//   85  */

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA8
//   86 static uint8_t sInit_done = 0;
sInit_done:
        DS 1
        REQUIRE __INIT_XDATA_Z
//   87 
//   88 /******************************************************************************
//   89  * LOCAL FUNCTIONS
//   90  */
//   91 static uint8_t ioctlPreInitAccessIsOK(ioctlObject_t);
//   92 
//   93 /******************************************************************************
//   94  * GLOBAL VARIABLES
//   95  */
//   96 
//   97 /******************************************************************************
//   98  * GLOBAL FUNCTIONS
//   99  */
//  100 
//  101 /***********************************************************************************
//  102  * @fn          SMPL_Init
//  103  *
//  104  * @brief       Initialize the SimpliciTI stack.
//  105  *
//  106  * input parameters
//  107  * @param   f  - Pointer to call back function. Function called by NWK when
//  108  *               user application frame received. The callback is done in the
//  109  *               ISR thread. Argument is Link ID associated with frame. Function
//  110  *               returns 0 if frame is to be kept by NWK, otherwise 1. Frame
//  111  *               should be kept if application will do a SMPL_Receive() in the
//  112  *               user thread (recommended). Pointer may be NULL.
//  113  *
//  114  * output parameters
//  115  *
//  116  * @return   Status of operation:
//  117  *             SMPL_SUCCESS
//  118  *             SMPL_NO_JOIN     No Join reply. AP possibly not yet up.
//  119  *             SMPL_NO_CHANNEL  Only if Frequency Agility enabled. Channel scan
//  120  *                              failed. AP possibly not yet up.
//  121  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  122 smplStatus_t SMPL_Init(uint8_t (*f)(linkID_t))
SMPL_Init:
        CODE
//  123 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        MOV     A,#-0x2
        LCALL   ?ADD_XSTACK_DISP0_8
        LCALL   ?XSTACK_SAVE_DPTRS_1
        ; Saved register size: 10
        ; Auto size: 0
        MOV     DPL,R2
        MOV     DPH,R3
//  124   smplStatus_t rc;
//  125 
//  126   if (!sInit_done)
        ; Selecting DPTR 1 by inc-method (DPSEL=0)
        INC     ?DPS
        MOV     DPTR/*1*/,#sInit_done
        MOVX    A,@DPTR/*1*/
        JNZ     ??SMPL_Init_0
//  127   {
//  128     /* set up radio. */
//  129     MRFI_Init();
        ; Setup parameters for call to function MRFI_Init
        LCALL   MRFI_Init
//  130 
//  131     /* initialize network */
//  132     if ((rc=nwk_nwkInit(f)) != SMPL_SUCCESS)
        ; Setup parameters for call to function nwk_nwkInit
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   nwk_nwkInit
        MOV     A,R1
        JNZ     ??SMPL_Init_1
//  133     {
//  134       return rc;
//  135     }
//  136 
//  137     MRFI_WakeUp();
        ; Setup parameters for call to function MRFI_WakeUp
        LCALL   MRFI_WakeUp
//  138 #if defined( FREQUENCY_AGILITY )
//  139     {
//  140       freqEntry_t chan;
//  141 
//  142       chan.logicalChan = 0;
//  143       /* ok to set default channel explicitly now that MRFI initialized. */
//  144       nwk_setChannel(&chan);
//  145     }
//  146 #endif
//  147     /* don't turn Rx on if we're an end device that isn't always on. */
//  148     /* but do turn the radio on for PLL operations */
//  149 #if !defined( END_DEVICE ) || defined( NWK_PLL )
//  150     MRFI_RxOn();
//  151 #endif
//  152 
//  153 #if defined( END_DEVICE )
//  154     /* All except End Devices are in promiscuous mode */
//  155     MRFI_SetRxAddrFilter((uint8_t *)nwk_getMyAddress());
        ; Setup parameters for call to function MRFI_SetRxAddrFilter
        ; Setup parameters for call to function nwk_getMyAddress
        LCALL   nwk_getMyAddress
        LCALL   MRFI_SetRxAddrFilter
//  156     MRFI_EnableRxAddrFilter();
        ; Setup parameters for call to function MRFI_EnableRxAddrFilter
        LCALL   MRFI_EnableRxAddrFilter
//  157 #endif
//  158   }
//  159   sInit_done = 1;
??SMPL_Init_0:
        ; Selecting DPTR 0 by inc-method (DPSEL=x)
        ANL     ?DPS,#0xfe
        MOV     DPTR,#sInit_done
        MOV     A,#0x1
        MOVX    @DPTR,A
//  160 
//  161 #ifdef NWK_PLL
//  162   /* If the PLL is enabled then it must get running before the join
//  163    * request or the system may lock up in the join request becuase
//  164    * PLL is not locked in.
//  165    */
//  166   // turn on the PLL
//  167   SMPL_Ioctl(IOCTL_OBJ_PLL, IOCTL_ACT_ON, NULL);
//  168   // reference clocks are by definition always locked.
//  169   #ifndef NWK_PLL_REFERENCE_CLOCK
//  170     // wait for a 5ms failure rate to be achieved
//  171     while( nwk_pllIsLocked( 0 ) == false )
//  172       nwk_pllBackgrounder( false );
//  173   #endif
//  174 #endif
//  175 
//  176   /* Join. if no AP or Join fails that status is returned. */
//  177   rc = nwk_join();
//  178 
//  179   return rc;
        ; Setup parameters for call to function nwk_join
        LCALL   nwk_join
??SMPL_Init_1:
        REQUIRE ?Subroutine0
        ; // Fall through to label ?Subroutine0
//  180 }

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine0:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        LCALL   ?XSTACK_RESTORE_DPTRS_1
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x1
        LJMP    ?FUNC_LEAVE_XDATA
//  181 
//  182 /******************************************************************************
//  183  * @fn          SMPL_LinkListen
//  184  *
//  185  * @brief       Listen for a link frame from a 'client' device.
//  186  *
//  187  * input parameters
//  188  *
//  189  * output parameters
//  190  * @param   linkID     - pointer to Link ID to be used by application to
//  191  *                       read and write to the linked peer.
//  192  *
//  193  * @return   status of operation.
//  194  *             SMPL_SUCCESS
//  195  *             SMPL_TIMEOUT  No link frame received during listen interval.
//  196 *                            Interval set in #defines above. linkID not valid.
//  197  *
//  198  */
//  199 

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  200 smplStatus_t SMPL_LinkListen(linkID_t *linkID)
SMPL_LinkListen:
        CODE
//  201 {
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
        MOV     DPL,R2
        MOV     DPH,R3
//  202   uint8_t  radioState = MRFI_GetRadioState();
        ; Setup parameters for call to function MRFI_GetRadioState
        LCALL   MRFI_GetRadioState
        MOV     A,R1
        MOV     ?V0 + 0,A
//  203   uint16_t i;
//  204   linkID_t locLinkID;
//  205 
//  206   /* Set the context. We want to reject any link frames received if
//  207    * we're not listening. For example if we're an AP we are in
//  208    * promiscuous mode and we'll see any broadcast link frames.
//  209    */
//  210   nwk_setListenContext(LINK_LISTEN_ON);
        ; Setup parameters for call to function nwk_setListenContext
        MOV     R1,#0x0
        LCALL   nwk_setListenContext
//  211 
//  212   NWK_CHECK_FOR_SETRX(radioState);
        MOV     A,#0x3
        XRL     A,?V0 + 0
        JZ      ??SMPL_LinkListen_0
        MOV     A,#0x1
        XRL     A,?V0 + 0
        JNZ     ??SMPL_LinkListen_1
        ; Setup parameters for call to function MRFI_WakeUp
        LCALL   MRFI_WakeUp
??SMPL_LinkListen_1:
        ; Setup parameters for call to function MRFI_RxOn
        LCALL   MRFI_RxOn
//  213 
//  214   for (i=0; i<LINKLISTEN_POLL_COUNT; ++i)
??SMPL_LinkListen_0:
        MOV     R6,#-0xc
        MOV     R7,#0x1
//  215   {
//  216     /* check the semaphore. local port is assigned when the reply is sent. */
//  217     if ((locLinkID=nwk_getLocalLinkID()))
??SMPL_LinkListen_2:
        ; Setup parameters for call to function nwk_getLocalLinkID
        LCALL   nwk_getLocalLinkID
        MOV     A,R1
        MOV     R0,A
        MOV     ?V0 + 1,R0
        JNZ     ??SMPL_LinkListen_3
//  218     {
//  219       break;
//  220     }
//  221     NWK_DELAY(LINKLISTEN_POLL_PERIOD_MS);
        ; Setup parameters for call to function MRFI_DelayMs
        MOV     R2,#0xa
        MOV     R3,#0x0
        LCALL   MRFI_DelayMs
//  222   }
        MOV     A,R6
        ADD     A,#-0x1
        DEC     R6
        MOV     A,R7
        ADDC    A,#-0x1
        MOV     R7,A
        MOV     A,R6
        ORL     A,R7
        JNZ     ??SMPL_LinkListen_2
//  223 
//  224   NWK_CHECK_FOR_RESTORE_STATE(radioState);
??SMPL_LinkListen_3:
        MOV     A,#0x3
        XRL     A,?V0 + 0
        JZ      ??SMPL_LinkListen_4
        MOV     A,#0x1
        XRL     A,?V0 + 0
        JNZ     ??SMPL_LinkListen_5
        ; Setup parameters for call to function MRFI_Sleep
        LCALL   MRFI_Sleep
        SJMP    ??SMPL_LinkListen_4
??SMPL_LinkListen_5:
        ; Setup parameters for call to function MRFI_RxIdle
        LCALL   MRFI_RxIdle
//  225 
//  226   /* If the listen is terminated without hearing a message and setting a
//  227    * link ID the listen context must be explicitly turned off.
//  228    */
//  229 	/* for sure we receive all message, so should listen always @yongfa */
//  230   if (!(locLinkID))
??SMPL_LinkListen_4:
        MOV     A,?V0 + 1
        JNZ     ??SMPL_LinkListen_6
//  231   {
//  232     /* nwk_setListenContext(LINK_LISTEN_OFF); */
//  233     return SMPL_TIMEOUT;
        MOV     R1,#0x1
        SJMP    ??SMPL_LinkListen_7
//  234   }
//  235 
//  236   *linkID = locLinkID;
??SMPL_LinkListen_6:
        MOVX    @DPTR,A
//  237 
//  238   return SMPL_SUCCESS;
        MOV     R1,#0x0
??SMPL_LinkListen_7:
        SJMP    ??Subroutine2_0
//  239 }
//  240 
//  241 /******************************************************************************
//  242  * @fn          SMPL_Send
//  243  *
//  244  * @brief       Send a message to a peer application. Old API kept for
//  245  *              backward compatibility. Calls the new SMPL_SendOpt() with
//  246  *              no options.
//  247  *
//  248  * input parameters
//  249  * @param   lid     - Link ID (port) from application
//  250  * @param   msg     - pointer to message from app to be sent
//  251  * @param   len     - length of enclosed message
//  252  *
//  253  * output parameters
//  254  *
//  255  * @return   Status of operation. On a filaure the frame buffer is discarded
//  256  *           and the Send call must be redone by the app.
//  257  *             SMPL_SUCCESS
//  258  *             SMPL_BAD_PARAM    No valid Connection Table entry for Link ID
//  259  *                               Data in Connection Table entry bad
//  260  *                               No message or message too long
//  261  *             SMPL_NOMEM        No room in output frame queue
//  262  *             SMPL_TX_CCA_FAIL  CCA failure.
//  263  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  264 smplStatus_t SMPL_Send(linkID_t lid, uint8_t *msg, uint8_t len)
SMPL_Send:
        CODE
//  265 {
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        ; Saved register size: 9
        ; Auto size: 0
//  266   return SMPL_SendOpt(lid, msg, len, SMPL_TXOPTION_NONE);
        ; Setup parameters for call to function SMPL_SendOpt
        CLR     A
        MOV     ?V0 + 0,A
        MOV     ?V0 + 1,A
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        LCALL   SMPL_SendOpt
        REQUIRE ?Subroutine1
        ; // Fall through to label ?Subroutine1
//  267 }

        RSEG NEAR_CODE:CODE:NOROOT(0)
?Subroutine1:
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        REQUIRE ??Subroutine2_0
        ; // Fall through to label ??Subroutine2_0

        RSEG NEAR_CODE:CODE:NOROOT(0)
??Subroutine2_0:
        MOV     R7,#0x2
        LJMP    ?FUNC_LEAVE_XDATA
//  268 
//  269 /******************************************************************************
//  270  * @fn          SMPL_SendOpt
//  271  *
//  272  * @brief       Send a message to a peer application.
//  273  *
//  274  * input parameters
//  275  * @param   lid     - Link ID (port) from application
//  276  * @param   msg     - pointer to message from app to be sent
//  277  * @param   len     - length of enclosed message
//  278  * @param   options - Transmit options (bit map)
//  279  *
//  280  * output parameters
//  281  *
//  282  * @return   Status of operation. On a filaure the frame buffer is discarded
//  283  *           and the Send call must be redone by the app.
//  284  *             SMPL_SUCCESS
//  285  *             SMPL_BAD_PARAM    No valid Connection Table entry for Link ID
//  286  *                               Data in Connection Table entry bad
//  287  *                               No message or message too long
//  288  *             SMPL_NOMEM        No room in output frame queue
//  289  *             SMPL_TX_CCA_FAIL  CCA failure.
//  290  *             SMPL_NO_ACK       If application auto acknowledgement enabled
//  291  *                               and no acknowledgement is received
//  292  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  293 smplStatus_t SMPL_SendOpt(linkID_t lid, uint8_t *msg, uint8_t len, txOpt_t options)
SMPL_SendOpt:
        CODE
//  294 {
        MOV     A,#-0xe
        LCALL   ?FUNC_ENTER_XDATA
        MOV     A,#-0x2
        LCALL   ?ADD_XSTACK_DISP0_8
        LCALL   ?XSTACK_SAVE_DPTRS_1
        ; Saved register size: 16
        ; Auto size: 0
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     A,R4
        MOV     R7,A
        MOV     A,#0x10
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 5,A
//  295   frameInfo_t  *pFrameInfo;
//  296   connInfo_t   *pCInfo     = nwk_getConnInfo(lid);
        ; Setup parameters for call to function nwk_getConnInfo
        LCALL   nwk_getConnInfo
        MOV     ?DPL1,R2
        MOV     ?DPH1,R3
//  297   smplStatus_t  rc         = SMPL_BAD_PARAM;
        MOV     R6,#0x2
//  298   uint8_t       radioState = MRFI_GetRadioState();
        ; Setup parameters for call to function MRFI_GetRadioState
        LCALL   MRFI_GetRadioState
//  299   uint8_t       ackreq     = 0;
//  300 #if defined(ACCESS_POINT)
//  301   uint8_t  loc;
//  302 #endif
//  303 
//  304   /* we have the connection info for this Link ID. make sure it is valid. */
//  305    if (!pCInfo || ((rc=nwk_checkConnInfo(pCInfo, CHK_TX)) != SMPL_SUCCESS))
        MOV     A,?DPL1
        ORL     A,?DPH1
        JZ      ??SMPL_SendOpt_0
        ; Setup parameters for call to function nwk_checkConnInfo
        MOV     R1,#0x1
        MOV     R2,?DPL1
        MOV     R3,?DPH1
        LCALL   nwk_checkConnInfo
        MOV     A,R1
        MOV     R6,A
        JZ      ??SMPL_SendOpt_1
//  306   {
//  307     return rc;
??SMPL_SendOpt_0:
        MOV     A,R6
        MOV     R1,A
        SJMP    ??SMPL_SendOpt_2
//  308   }
//  309 
//  310   /* parameter sanity check... */
//  311   if (!msg || (len > MAX_APP_PAYLOAD))
??SMPL_SendOpt_1:
        MOV     A,?V0 + 0
        ORL     A,?V0 + 1
        JZ      ??SMPL_SendOpt_0
        MOV     A,R7
        CLR     C
        SUBB    A,#0x15
        JNC     ??SMPL_SendOpt_0
//  312   {
//  313     return rc;
//  314   }
//  315 
//  316   /* Build an outgoing message frame destined for the port from the
//  317    * connection info using the destination address also from the
//  318    * connection info.
//  319    */
//  320   if (SMPL_TXOPTION_NONE == options)
        MOV     A,?V0 + 4
        ORL     A,?V0 + 5
        JNZ     ??SMPL_SendOpt_3
//  321   {
//  322     pFrameInfo = nwk_buildFrame(pCInfo->portTx, msg, len, pCInfo->hops2target);
        ; Setup parameters for call to function nwk_buildFrame
        MOV     DPL,?DPL1
        MOV     DPH,?DPH1
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        MOV     A,R7
        MOV     R4,A
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        MOV     DPL,?DPL1
        MOV     DPH,?DPH1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   nwk_buildFrame
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
//  323   }
//  324 #if defined(APP_AUTO_ACK)
//  325   else if (options & SMPL_TXOPTION_ACKREQ)
//  326   {
//  327     if (SMPL_LINKID_USER_UUD != lid)
//  328     {
//  329       pFrameInfo = nwk_buildAckReqFrame(pCInfo->portTx, msg, len, pCInfo->hops2target, &pCInfo->ackTID);
//  330       ackreq     = 1;
//  331     }
//  332     else
//  333     {
//  334       /* can't request an ack on the UUD link ID */
//  335       return SMPL_BAD_PARAM;
//  336     }
//  337   }
//  338 #endif  /* APP_AUTO_ACK */
//  339   else
//  340   {
//  341     return SMPL_BAD_PARAM;
//  342   }
//  343 
//  344   if (!pFrameInfo)
        MOV     A,R2
        ORL     A,?V0 + 1
        JNZ     ??SMPL_SendOpt_4
//  345   {
//  346     return SMPL_NOMEM;
        MOV     R1,#0x3
        SJMP    ??SMPL_SendOpt_2
//  347   }
??SMPL_SendOpt_3:
        MOV     R1,#0x2
        SJMP    ??SMPL_SendOpt_2
//  348   memcpy(MRFI_P_DST_ADDR(&pFrameInfo->mrfiPkt), pCInfo->peerAddr, NET_ADDR_SIZE);
??SMPL_SendOpt_4:
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 2,#0x1
        MOV     ?V0 + 3,#0x0
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     A,?DPL1
        ADD     A,#0x2
        MOV     R4,A
        MOV     A,?DPH1
        ADDC    A,#0x0
        MOV     R5,A
        MOV     A,R2
        ADD     A,#0x3
        INC     R2
        INC     R2
        INC     R2
        MOV     A,R3
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   memcpy
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
//  349 
//  350 #if defined(SMPL_SECURE)
//  351   {
//  352     uint32_t *pUL = 0;
//  353 
//  354     if (pCInfo->thisLinkID != SMPL_LINKID_USER_UUD)
//  355     {
//  356       pUL = &pCInfo->connTxCTR;
//  357     }
//  358     nwk_setSecureFrame(&pFrameInfo->mrfiPkt, len, pUL);
//  359   }
//  360 #endif  /* SMPL_SECURE */
//  361 
//  362 #if defined(ACCESS_POINT)
//  363   /* If we are an AP trying to send to a polling device, don't do it.
//  364    * See if the target is a store-and-forward client.
//  365    */
//  366   if (nwk_isSandFClient(MRFI_P_DST_ADDR(&pFrameInfo->mrfiPkt), &loc))
//  367   {
//  368      pFrameInfo->fi_usage = FI_INUSE_UNTIL_FWD;
//  369      return SMPL_SUCCESS;
//  370   }
//  371   else
//  372 #endif  /* ACCESS_POINT */
//  373   {
//  374     rc = nwk_sendFrame(pFrameInfo, MRFI_TX_TYPE_CCA);
//  375   }
//  376 
//  377 #if !defined(APP_AUTO_ACK)
//  378   /* save a little code space with this #if */
//  379   (void) ackreq;    /* keep compiler happy */
//  380   return rc;
        ; Setup parameters for call to function nwk_sendFrame
        MOV     R1,#0x1
        MOV     R2,?V0 + 0
        MOV     R3,?V0 + 1
        LCALL   nwk_sendFrame
??SMPL_SendOpt_2:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        LCALL   ?XSTACK_RESTORE_DPTRS_1
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x7
        LJMP    ?FUNC_LEAVE_XDATA
//  381 #else
//  382   /* we're done if the send failed or no ack requested. */
//  383   if (SMPL_SUCCESS != rc || !ackreq)
//  384   {
//  385     return rc;
//  386   }
//  387 
//  388   NWK_CHECK_FOR_SETRX(radioState);
//  389   NWK_REPLY_DELAY();
//  390   NWK_CHECK_FOR_RESTORE_STATE(radioState);
//  391 
//  392   {
//  393     bspIState_t intState;
//  394 
//  395     /* If the saved TID hasn't been reset then we never got the ack. */
//  396     BSP_ENTER_CRITICAL_SECTION(intState);
//  397     if (pCInfo->ackTID)
//  398     {
//  399       pCInfo->ackTID = 0;
//  400       rc = SMPL_NO_ACK;
//  401     }
//  402     BSP_EXIT_CRITICAL_SECTION(intState);
//  403   }
//  404 
//  405   return rc;
//  406 #endif  /* APP_AUTO_ACK */
//  407 }
//  408 
//  409 /**************************************************************************************
//  410  * @fn          SMPL_Receive
//  411  *
//  412  * @brief       Receive a message from a peer application.
//  413  *
//  414  * input parameters
//  415  * @param   lid     - Link ID (port) from application
//  416  *
//  417  *
//  418  * output parameters
//  419  * @param   msg     - pointer to where received message should be copied.
//  420  *                    buffer should be of size == MAX_APP_PAYLOAD
//  421  * @param   len     - pointer to receive length of received message
//  422  *
//  423  * @return    Status of operation.
//  424  *            Caller should not use the value returned in 'len' to decide
//  425  *            whether there is a frame or not. It could be useful to the
//  426  *            Caller to distinguish between no frame and a frame with no data.
//  427  *            For example, in the polling case a frame with no application payload
//  428  *            is the way the AP conveys that there are no frames waiting.
//  429  *
//  430  *              SMPL_SUCCESS
//  431  *
//  432  *              SMPL_BAD_PARAM  No valid Connection Table entry for Link ID
//  433  *                              Data in Connection Table entry bad
//  434  *              SMPL_NO_FRAME   No frame received.
//  435  *              SMPL_NO_PAYLOAD Frame received with no payload (not necessarily
//  436  *                              an error and could be deduced by application
//  437  *                              because the returned length will be 0)
//  438  *
//  439  *            Polling device only:
//  440  *
//  441  *              SMPL_TIMEOUT        No response from Access Point
//  442  *              SMPL_NO_AP_ADDRESS  Access Point address unknown
//  443  *              SMPL_TX_CCA_FAIL    Could not send poll frame
//  444  *              SMPL_NOMEM          No memory in output frame queue
//  445  *              SMPL_NO_CHANNEL     Frequency Agility enabled and could not find channel
//  446  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  447 smplStatus_t SMPL_Receive(linkID_t lid, uint8_t *msg, uint8_t *len)
SMPL_Receive:
        CODE
//  448 {
        MOV     A,#-0xb
        LCALL   ?FUNC_ENTER_XDATA
        MOV     A,#-0x2
        LCALL   ?ADD_XSTACK_DISP0_8
        LCALL   ?XSTACK_SAVE_DPTRS_1
        ; Saved register size: 13
        ; Auto size: 3
        MOV     A,#-0x3
        LCALL   ?ALLOC_XSTACK8
        MOV     A,R1
        MOV     R7,A
        MOV     ?DPL1,R2
        MOV     ?DPH1,R3
        MOV     ?V0 + 0,R4
        MOV     ?V0 + 1,R5
//  449   connInfo_t  *pCInfo = nwk_getConnInfo(lid);
        ; Setup parameters for call to function nwk_getConnInfo
        LCALL   nwk_getConnInfo
//  450   smplStatus_t rc = SMPL_BAD_PARAM;
        MOV     R6,#0x2
//  451   rcvContext_t rcv;
//  452 
//  453   if (!pCInfo || ((rc=nwk_checkConnInfo(pCInfo, CHK_RX)) != SMPL_SUCCESS))
        MOV     A,R2
        ORL     A,R3
        JZ      ??SMPL_Receive_0
        ; Setup parameters for call to function nwk_checkConnInfo
        MOV     R1,#0x0
        LCALL   nwk_checkConnInfo
        MOV     A,R1
        MOV     R6,A
        JZ      ??SMPL_Receive_1
//  454   {
//  455     return rc;
??SMPL_Receive_0:
        MOV     A,R6
        MOV     R1,A
        SJMP    ??SMPL_Receive_2
//  456   }
//  457 
//  458   rcv.type  = RCV_APP_LID;
??SMPL_Receive_1:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOV     A,#0x1
        MOVX    @DPTR,A
//  459   rcv.t.lid = lid;
        LCALL   ?XSTACK_DISP0_8
        MOV     A,R7
        MOVX    @DPTR,A
//  460 
//  461 #if defined(RX_POLLS)
//  462   {
//  463     uint8_t numChans  = 1;
//  464 #if defined(FREQUENCY_AGILITY)
//  465     freqEntry_t chans[NWK_FREQ_TBL_SIZE];
//  466     uint8_t     scannedB4 = 0;
//  467 #endif
//  468 
//  469     do
//  470     {
//  471       uint8_t radioState = MRFI_GetRadioState();
//  472 
//  473       /* I'm polling. Do the poll to stimulate the sending of a frame. If the
//  474        * frame has application length of 0 it means there were no frames.  If
//  475        * no reply is received infer that the channel is changed. We then need
//  476        * to scan and then retry the poll on each channel returned.
//  477        */
//  478       if (SMPL_SUCCESS != (rc=nwk_poll(pCInfo->portRx, pCInfo->peerAddr)))
//  479       {
//  480         /* for some reason couldn't send the poll out. */
//  481         return rc;
//  482       }
//  483 
//  484       /* do this before code block below which may reset it. */
//  485       numChans--;
//  486 
//  487       /* Wait until there's a frame. if the len is 0 then return SMPL_NO_FRAME
//  488        * to the caller. In the poll case the AP always sends something.
//  489        */
//  490       NWK_CHECK_FOR_SETRX(radioState);
//  491       NWK_REPLY_DELAY();
//  492       NWK_CHECK_FOR_RESTORE_STATE(radioState);
//  493 
//  494       /* TODO: deal with pending */
//  495       rc = nwk_retrieveFrame(&rcv, msg, len, 0, 0);
//  496 
//  497 #if defined(FREQUENCY_AGILITY)
//  498       if (SMPL_SUCCESS == rc)
//  499       {
//  500         /* we received something... */
//  501         return (*len) ? SMPL_SUCCESS : SMPL_NO_PAYLOAD;
//  502       }
//  503 
//  504       /* No reply. scan for other channel(s) if we haven't already. Then set
//  505        * one and try again.
//  506        */
//  507       if (!scannedB4)
//  508       {
//  509         numChans  = nwk_scanForChannels(chans);
//  510         scannedB4 = 1;
//  511       }
//  512       if (numChans)
//  513       {
//  514         nwk_setChannel(&chans[numChans-1]);
//  515       }
//  516 #else /*  FREQUENCY_AGILITY */
//  517       return (*len) ? rc : ((SMPL_SUCCESS == rc) ? SMPL_NO_PAYLOAD : SMPL_TIMEOUT);
//  518 #endif
//  519     } while (numChans);
//  520   }
//  521 
//  522 #if defined(FREQUENCY_AGILITY)
//  523   return SMPL_NO_CHANNEL;
//  524 #endif
//  525 
//  526 #else  /* RX_POLLS */
//  527   return nwk_retrieveFrame(&rcv, msg, len, 0, 0);
        ; Setup parameters for call to function nwk_retrieveFrame
        CLR     A
        MOV     ?V0 + 2,A
        MOV     ?V0 + 3,A
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R0,#?V0 + 2
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R4,?DPL1
        MOV     R5,?DPH1
        MOV     A,#0x6
        LCALL   ?XSTACK_DISP0_8
        MOV     R2,DPL
        MOV     R3,DPH
        LCALL   nwk_retrieveFrame
        MOV     A,#0x6
        LCALL   ?DEALLOC_XSTACK8
??SMPL_Receive_2:
        MOV     A,#0x3
        LCALL   ?DEALLOC_XSTACK8
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        LCALL   ?XSTACK_RESTORE_DPTRS_1
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x4
        LJMP    ?FUNC_LEAVE_XDATA
//  528 #endif  /* RX_POLLS */
//  529 }
//  530 
//  531 
//  532 /******************************************************************************
//  533  * @fn          SMPL_Link
//  534  *
//  535  * @brief       Link to a peer.
//  536  *
//  537  * input parameters
//  538  *
//  539  * output parameters
//  540  * @param   lid     - pointer to where we should write the link ID to which the
//  541  *                    application will read and write.
//  542  *
//  543  * @return   Status of operation.
//  544  *             SMPL_SUCCESS
//  545  *             SMPL_NOMEM         No room to allocate local Rx port, no more
//  546  *                                room in Connection Table, or no room in
//  547  *                                output frame queue.
//  548  *             SMPL_NO_LINK       No reply frame during wait window.
//  549  *             SMPL_TX_CCA_FAIL   Could not send Link frame.
//  550  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  551 smplStatus_t SMPL_Link(linkID_t *lid, uint8 dstAddr)
SMPL_Link:
        CODE
//  552 {
        MOV     A,#-0x8
        LCALL   ?FUNC_ENTER_XDATA
        MOV     A,#-0x2
        LCALL   ?ADD_XSTACK_DISP0_8
        LCALL   ?XSTACK_SAVE_DPTRS_1
        ; Saved register size: 10
        ; Auto size: 1
        MOV     A,#-0x1
        LCALL   ?ALLOC_XSTACK8
        MOV     A,R1
//  553 	addr_t addr;
//  554 	addr.addr[0] = dstAddr;
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        MOVX    @DPTR,A
//  555   return nwk_link(lid, addr);
        ; Setup parameters for call to function nwk_link
        MOV     ?DPL1,?XSP + 0
        MOV     ?DPH1,?XSP + 1
        MOV     A,#0x1
        ; Selecting DPTR 1 by inc-method (DPSEL=0)
        INC     ?DPS
        LCALL   ?PUSH_XSTACK8_X_2DPTR
        LCALL   nwk_link
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        MOV     A,#0x1
        LCALL   ?DEALLOC_XSTACK8
        LJMP    ?Subroutine0
//  556 }
//  557 
//  558 #if defined(EXTENDED_API)
//  559 /**************************************************************************************
//  560  * @fn          SMPL_Unlink
//  561  *
//  562  * @brief       Tear down connection to a peer.
//  563  *
//  564  * input parameters
//  565  * @param   lid     - Link ID whose connection is to be terminated.
//  566  *
//  567  * output parameters
//  568  *
//  569  * @return   Status of operation. The Connection Table entry for the Link ID
//  570  *           is always freed successfuly. The returned status value is the
//  571  *           status of the _peer's_ connection tear-down as a result of the
//  572  *           message sent here.
//  573  *           SMPL_SUCCESS         Local and remote connection destroyed.
//  574  *           SMPL_BAD_PARAM       No local connection table entry for this Link ID
//  575  *           SMPL_TIMEOUT         No reply from peer.
//  576  *           SMPL_NO_PEER_UNLINK  Peer did not have a Connection Table entry for me.
//  577  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  578 smplStatus_t SMPL_Unlink(linkID_t lid)
SMPL_Unlink:
        CODE
//  579 {
        MOV     A,R6
        PUSH    A
        ; Saved register size: 1
        ; Auto size: 0
//  580   return nwk_unlink(lid);
        ; Setup parameters for call to function nwk_unlink
        LCALL   nwk_unlink
        POP     A
        MOV     R6,A
        RET
//  581 }
//  582 
//  583 /**************************************************************************************
//  584  * @fn          SMPL_Ping
//  585  *
//  586  * @brief       Ping a peer. Synchronous call. Although a link ID is used it is the
//  587  *              NWK Ping application that is pinged, not the peer of this Link ID. The
//  588  *              peer is not expected to be the responder to the frame sent from here.
//  589  *              This API is a proxy for a real ping since the application doesn't
//  590  *              have direct access to SimpliciTI device addresses. Kind of hokey but a
//  591  *              useful keep-alive mechanism without having to support it with
//  592  *              user application service.
//  593  *
//  594  * input parameters
//  595  * @param   lid  - The link ID whose peer device address is used to direct the NWK Ping
//  596  *
//  597  * output parameters
//  598  *
//  599  * @return   Status of operation.
//  600  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  601 smplStatus_t SMPL_Ping(linkID_t lid)
SMPL_Ping:
        CODE
//  602 {
        MOV     A,R6
        PUSH    A
        ; Saved register size: 1
        ; Auto size: 0
//  603   return nwk_ping(lid);
        ; Setup parameters for call to function nwk_ping
        LCALL   nwk_ping
        POP     A
        MOV     R6,A
        RET
//  604 }
//  605 
//  606 /**************************************************************************************
//  607  * @fn          SMPL_Commission
//  608  *
//  609  * @brief       Commission a connection.
//  610  *
//  611  * input parameters
//  612  * @param   peerAddr  - Pointer to address of the peer for this connection
//  613  * @param    locPort  - Port on which to listen for messages from the peer
//  614  * @param    rmtPort  - Port on which to send messages to the peer.
//  615  * @param        lid  - Pointer to Link ID object. If content of location is
//  616  *                      non-zero on input the value is placed in the Connection
//  617  *                      object.
//  618  *
//  619  * output parameters
//  620  * @param        lid  - Pointer to Link ID object. If content of location is zero
//  621  *                      on input the value in the Connection object is stored there.
//  622  *
//  623  * @return   SMPL_SUCCESS
//  624  *           SMPL_NOMEM     - No room left in Connection table.
//  625  *           SMPL_BAD_PARAM - A pointer to a Link object was not supplied.
//  626  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  627 smplStatus_t SMPL_Commission(addr_t *peerAddr, uint8_t locPort, uint8_t rmtPort, linkID_t *lid)
SMPL_Commission:
        CODE
//  628 {
        MOV     A,#-0xd
        LCALL   ?FUNC_ENTER_XDATA
        MOV     A,#-0x2
        LCALL   ?ADD_XSTACK_DISP0_8
        LCALL   ?XSTACK_SAVE_DPTRS_1
        ; Saved register size: 15
        ; Auto size: 0
        MOV     ?V0 + 4,R2
        MOV     ?V0 + 5,R3
        MOV     A,R1
        MOV     R7,A
        MOV     A,R4
        MOV     R6,A
        MOV     A,#0xf
        LCALL   ?XSTACK_DISP0_8
        MOVX    A,@DPTR
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     ?V0 + 3,A
//  629   connInfo_t   *pCInfo = nwk_getNextConnection();
        ; Setup parameters for call to function nwk_getNextConnection
        LCALL   nwk_getNextConnection
        MOV     ?DPL1,R2
        MOV     ?DPH1,R3
//  630   smplStatus_t  rc     = SMPL_BAD_PARAM;
        MOV     ?V0 + 0,#0x2
//  631 
//  632   do {
//  633     if (pCInfo)
        MOV     A,?DPL1
        ORL     A,?DPH1
        JZ      ??SMPL_Commission_0
//  634     {
//  635       /* sanity checks... */
//  636 
//  637       /* Check port info. */
//  638       if ((locPort > SMPL_PORT_STATIC_MAX) || (locPort < (SMPL_PORT_STATIC_MAX - PORT_USER_STATIC_NUM + 1)))
        MOV     A,#-0x3e
        ADD     A,R7
        JNZ     ??SMPL_Commission_1
//  639       {
//  640         continue;
//  641       }
//  642 
//  643       if ((rmtPort > SMPL_PORT_STATIC_MAX) || (rmtPort < (SMPL_PORT_STATIC_MAX - PORT_USER_STATIC_NUM + 1)))
        MOV     A,#-0x3e
        ADD     A,R6
        JNZ     ??SMPL_Commission_1
//  644       {
//  645         continue;
//  646       }
//  647 
//  648       /* Must supply a pointer to the Link ID object */
//  649       if (!lid)
        MOV     A,?V0 + 2
        ORL     A,?V0 + 3
        JZ      ??SMPL_Commission_1
//  650       {
//  651         /* No Link ID pointer supplied */
//  652         continue;
//  653       }
//  654 
//  655       /* we're sane */
//  656 
//  657       /* Use the value generated at connection object assign time. */
//  658       *lid = pCInfo->thisLinkID;
        MOV     DPL,?DPL1
        MOV     DPH,?DPH1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        MOV     DPL,?V0 + 2
        MOV     DPH,?V0 + 3
        MOVX    @DPTR,A
//  659 
//  660       /* store peer's address */
//  661       memcpy(pCInfo->peerAddr, peerAddr, NET_ADDR_SIZE);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 0,#0x1
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        MOV     R4,?V0 + 4
        MOV     R5,?V0 + 5
        MOV     A,?DPL1
        ADD     A,#0x2
        INC     R2
        INC     R2
        MOV     A,?DPH1
        ADDC    A,#0x0
        MOV     R3,A
        LCALL   memcpy
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
//  662 
//  663       /* store port info */
//  664       pCInfo->portRx = locPort;
        MOV     A,R7
        MOV     DPL,?DPL1
        MOV     DPH,?DPH1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
//  665       pCInfo->portTx = rmtPort;
        MOV     A,R6
        MOV     DPL,?DPL1
        MOV     DPH,?DPH1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVX    @DPTR,A
//  666 
//  667       pCInfo->hops2target = MAX_HOPS;
        ; Selecting DPTR 1 by inc-method (DPSEL=0)
        INC     ?DPS
        INC     DPTR/*1*/
        MOV     A,#0x3
        MOVX    @DPTR/*1*/,A
//  668 
//  669       rc = SMPL_SUCCESS;
        MOV     ?V0 + 0,#0x0
        SJMP    ??SMPL_Commission_2
//  670     }
//  671     else
//  672     {
//  673       /* No room in Connection table */
//  674       rc = SMPL_NOMEM;
??SMPL_Commission_0:
        MOV     ?V0 + 0,#0x3
        SJMP    ??SMPL_Commission_2
//  675     }
//  676   } while (0);
//  677 
//  678   if ((SMPL_SUCCESS != rc) && pCInfo)
//  679   {
//  680     nwk_freeConnection(pCInfo);
??SMPL_Commission_1:
        ; Setup parameters for call to function nwk_freeConnection
        LCALL   nwk_freeConnection
//  681   }
//  682 
//  683   return rc;
??SMPL_Commission_2:
        MOV     R1,?V0 + 0
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        ; Selecting DPTR 0 by inc-method (DPSEL=x)
        ANL     ?DPS,#0xfe
        LCALL   ?XSTACK_RESTORE_DPTRS_1
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
        MOV     R7,#0x6
        LJMP    ?FUNC_LEAVE_XDATA
//  684 }
//  685 #endif   /* EXTENDED_API */
//  686 
//  687 /******************************************************************************
//  688  * @fn          SMPL_Ioctl
//  689  *
//  690  * @brief       This routine supplies the SimpliciTI IOCTL support.
//  691  *
//  692  * input parameters
//  693  * @param   object   - The IOCTL target object
//  694  * @param   action   - The IOCTL target action on the object
//  695  * @param   val      - pointer to value. exact forn depends on object type.
//  696  *
//  697  * output parameters
//  698  *
//  699  * @return   Status of action. Value depends on object, action, and result.
//  700  *
//  701  *           SMPL_BAD_PARAM is returned if this API is called before
//  702  *                          initialization and the object is not one of
//  703  *                          the valid exceptions.
//  704  */

        RSEG NEAR_CODE:CODE:NOROOT(0)
//  705 smplStatus_t SMPL_Ioctl(ioctlObject_t object, ioctlAction_t action, void *val)
SMPL_Ioctl:
        CODE
//  706 {
        MOV     A,#-0x9
        LCALL   ?FUNC_ENTER_XDATA
        MOV     A,#-0x2
        LCALL   ?ADD_XSTACK_DISP0_8
        LCALL   ?XSTACK_SAVE_DPTRS_1
        ; Saved register size: 11
        ; Auto size: 0
        MOV     A,R1
        MOV     R7,A
        MOV     A,R2
        MOV     R6,A
        MOV     ?DPL1,R4
        MOV     ?DPH1,R5
//  707   smplStatus_t rc;
//  708 
//  709   /* if init hasn't occurred see if access is still valid */
//  710   if (!sInit_done && !ioctlPreInitAccessIsOK(object))
        MOV     DPTR,#sInit_done
        MOVX    A,@DPTR
        JNZ     ??SMPL_Ioctl_0
        MOV     A,R7
        ADD     A,#-0x5
        JZ      ??SMPL_Ioctl_0
        ADD     A,#-0x5
        JZ      ??SMPL_Ioctl_0
//  711   {
//  712     return SMPL_BAD_PARAM;
        MOV     R1,#0x2
        LJMP    ??SMPL_Ioctl_1
//  713   }
//  714 
//  715   switch (object)
??SMPL_Ioctl_0:
        MOV     A,R7
        ADD     A,#-0x2
        JNZ     $+5
        LJMP    ??SMPL_Ioctl_2
        DEC     A
        JNZ     $+5
        LJMP    ??SMPL_Ioctl_3
        ADD     A,#-0x2
        JNZ     $+5
        LJMP    ??SMPL_Ioctl_4
        DEC     A
        JZ      ??SMPL_Ioctl_5
        DEC     A
        JNZ     $+5
        LJMP    ??SMPL_Ioctl_6
        DEC     A
        JNZ     $+5
        LJMP    ??SMPL_Ioctl_7
        DEC     A
        JZ      ??SMPL_Ioctl_8
        DEC     A
        JNZ     ??SMPL_Ioctl_9
//  716   {
//  717 #if defined(EXTENDED_API)
//  718     case IOCTL_OBJ_TOKEN:
//  719       {
//  720         ioctlToken_t *t = (ioctlToken_t *)val;
//  721 
//  722         rc = SMPL_SUCCESS;
        MOV     ?V0 + 0,#0x0
//  723         if (TT_LINK == t->tokenType)
        ; Selecting DPTR 1 by inc-method (DPSEL=0)
        INC     ?DPS
        MOVX    A,@DPTR/*1*/
        JNZ     ??SMPL_Ioctl_10
//  724         {
//  725           if (IOCTL_ACT_SET == action)
        MOV     A,R6
        JNZ     ??SMPL_Ioctl_11
//  726           {
//  727             nwk_setLinkToken(t->token.linkToken);
        ; Setup parameters for call to function nwk_setLinkToken
        INC     DPTR/*1*/
        MOV     DPL,?DPL1
        MOV     DPH,?DPH1
        ; Selecting DPTR 0 by inc-method (DPSEL=1)
        INC     ?DPS
        LCALL   ?XLOAD_R2345
        LCALL   nwk_setLinkToken
        LJMP    ??SMPL_Ioctl_12
//  728           }
//  729           else if (IOCTL_ACT_GET == action)
??SMPL_Ioctl_11:
        MOV     A,#0x1
        XRL     A,R6
        JNZ     ??SMPL_Ioctl_9
//  730           {
//  731             nwk_getLinkToken(&t->token.linkToken);
        ; Setup parameters for call to function nwk_getLinkToken
        INC     DPTR/*1*/
        MOV     R2,?DPL1
        MOV     R3,?DPH1
        LCALL   nwk_getLinkToken
        LJMP    ??SMPL_Ioctl_12
//  732           }
//  733           else
//  734           {
//  735             rc = SMPL_BAD_PARAM;
??SMPL_Ioctl_9:
        MOV     ?V0 + 0,#0x2
        LJMP    ??SMPL_Ioctl_12
//  736           }
//  737         }
//  738         else if (TT_JOIN == t->tokenType)
??SMPL_Ioctl_10:
        XRL     A,#0x1
        JNZ     ??SMPL_Ioctl_9
//  739         {
//  740           if (IOCTL_ACT_SET == action)
        MOV     A,R6
        JNZ     ??SMPL_Ioctl_13
//  741           {
//  742             nwk_setJoinToken(t->token.joinToken);
        ; Setup parameters for call to function nwk_setJoinToken
        INC     DPTR/*1*/
        MOV     DPL,?DPL1
        MOV     DPH,?DPH1
        ; Selecting DPTR 0 by inc-method (DPSEL=1)
        INC     ?DPS
        LCALL   ?XLOAD_R2345
        LCALL   nwk_setJoinToken
        LJMP    ??SMPL_Ioctl_12
//  743           }
//  744           else if (IOCTL_ACT_GET == action)
??SMPL_Ioctl_13:
        MOV     A,#0x1
        XRL     A,R6
        JNZ     ??SMPL_Ioctl_9
//  745           {
//  746             nwk_getJoinToken(&t->token.joinToken);
        ; Setup parameters for call to function nwk_getJoinToken
        INC     DPTR/*1*/
        MOV     R2,?DPL1
        MOV     R3,?DPH1
        LCALL   nwk_getJoinToken
        LJMP    ??SMPL_Ioctl_12
//  747           }
//  748           else
//  749           {
//  750             rc = SMPL_BAD_PARAM;
//  751           }
//  752         }
//  753         else
//  754         {
//  755           rc = SMPL_BAD_PARAM;
//  756         }
//  757       }
//  758       break;
//  759 
//  760     case IOCTL_OBJ_NVOBJ:
//  761       rc = nwk_NVObj(action, (ioctlNVObj_t *)val);
??SMPL_Ioctl_8:
        ; Setup parameters for call to function nwk_NVObj
        MOV     R2,?DPL1
        MOV     R3,?DPH1
        MOV     A,R6
        MOV     R1,A
        LCALL   nwk_NVObj
??SMPL_Ioctl_14:
        MOV     A,R1
        MOV     ?V0 + 0,A
//  762       break;
        SJMP    ??SMPL_Ioctl_12
//  763 #endif  /* EXTENDED_API */
//  764 
//  765     case IOCTL_OBJ_CONNOBJ:
//  766       rc = nwk_connectionControl(action, val);
??SMPL_Ioctl_5:
        ; Setup parameters for call to function nwk_connectionControl
        MOV     R2,?DPL1
        MOV     R3,?DPH1
        MOV     A,R6
        MOV     R1,A
        LCALL   nwk_connectionControl
        SJMP    ??SMPL_Ioctl_14
//  767       break;
//  768 
//  769     case IOCTL_OBJ_ADDR:
//  770       if ((IOCTL_ACT_GET == action) || (IOCTL_ACT_SET == action))
??SMPL_Ioctl_4:
        MOV     A,#0x1
        XRL     A,R6
        JZ      ??SMPL_Ioctl_15
        MOV     A,R6
        JNZ     ??SMPL_Ioctl_9
//  771       {
//  772         rc = nwk_deviceAddress(action, (addr_t *)val);
??SMPL_Ioctl_15:
        ; Setup parameters for call to function nwk_deviceAddress
        MOV     R2,?DPL1
        MOV     R3,?DPH1
        MOV     A,R6
        MOV     R1,A
        LCALL   nwk_deviceAddress
        SJMP    ??SMPL_Ioctl_14
//  773       }
//  774       else
//  775       {
//  776         rc = SMPL_BAD_PARAM;
//  777       }
//  778       break;
//  779 
//  780     case IOCTL_OBJ_RAW_IO:
//  781       if (IOCTL_ACT_WRITE == action)
??SMPL_Ioctl_2:
        MOV     A,#0x3
        XRL     A,R6
        JNZ     ??SMPL_Ioctl_16
//  782       {
//  783         rc = nwk_rawSend((ioctlRawSend_t *)val);
        ; Setup parameters for call to function nwk_rawSend
        MOV     R2,?DPL1
        MOV     R3,?DPH1
        LCALL   nwk_rawSend
        SJMP    ??SMPL_Ioctl_14
//  784       }
//  785       else if (IOCTL_ACT_READ == action)
??SMPL_Ioctl_16:
        MOV     A,#0x2
        XRL     A,R6
        JNZ     ??SMPL_Ioctl_9
//  786       {
//  787         rc = nwk_rawReceive((ioctlRawReceive_t *)val);
        ; Setup parameters for call to function nwk_rawReceive
        MOV     R2,?DPL1
        MOV     R3,?DPH1
        LCALL   nwk_rawReceive
        SJMP    ??SMPL_Ioctl_14
//  788       }
//  789       else
//  790       {
//  791         rc = SMPL_BAD_PARAM;
//  792       }
//  793       break;
//  794 
//  795     case IOCTL_OBJ_RADIO:
//  796       rc = nwk_radioControl(action, val);
??SMPL_Ioctl_3:
        ; Setup parameters for call to function nwk_radioControl
        MOV     R2,?DPL1
        MOV     R3,?DPH1
        MOV     A,R6
        MOV     R1,A
        LCALL   nwk_radioControl
        SJMP    ??SMPL_Ioctl_14
//  797       break;
//  798 
//  799 #if defined(ACCESS_POINT)
//  800     case IOCTL_OBJ_AP_JOIN:
//  801       rc = nwk_joinContext(action);
//  802       break;
//  803 #endif
//  804 #if defined(FREQUENCY_AGILITY)
//  805     case IOCTL_OBJ_FREQ:
//  806       rc = nwk_freqControl(action, val);
//  807       break;
//  808 #endif
//  809 #if defined NWK_PLL
//  810     case IOCTL_OBJ_PLL:
//  811       rc = nwk_pllControl(action, val);
//  812       break;
//  813 #endif
//  814     case IOCTL_OBJ_FWVER:
//  815       if (IOCTL_ACT_GET == action)
??SMPL_Ioctl_6:
        MOV     A,#0x1
        XRL     A,R6
        JZ      $+5
        LJMP    ??SMPL_Ioctl_9
//  816       {
//  817         memcpy(val, nwk_getFWVersion(), SMPL_FWVERSION_SIZE);
        ; Setup parameters for call to function memcpy
        MOV     ?V0 + 0,#0x4
        MOV     ?V0 + 1,#0x0
        MOV     R0,#?V0 + 0
        LCALL   ?PUSH_XSTACK_I_TWO
        ; Setup parameters for call to function nwk_getFWVersion
        LCALL   nwk_getFWVersion
        MOV     A,R2
        MOV     R4,A
        MOV     A,R3
        MOV     R5,A
        MOV     R2,?DPL1
        MOV     R3,?DPH1
        LCALL   memcpy
        MOV     A,#0x2
        LCALL   ?DEALLOC_XSTACK8
//  818         rc = SMPL_SUCCESS;
        SJMP    ??SMPL_Ioctl_17
//  819       }
//  820       else
//  821       {
//  822         rc = SMPL_BAD_PARAM;
//  823       }
//  824       break;
//  825 
//  826     case IOCTL_OBJ_PROTOVER:
//  827       if (IOCTL_ACT_GET == action)
??SMPL_Ioctl_7:
        MOV     A,#0x1
        XRL     A,R6
        JZ      $+5
        LJMP    ??SMPL_Ioctl_9
//  828       {
//  829         *((uint8_t *)val) = nwk_getProtocolVersion();
        ; Setup parameters for call to function nwk_getProtocolVersion
        LCALL   nwk_getProtocolVersion
        MOV     A,R1
        ; Selecting DPTR 1 by inc-method (DPSEL=0)
        INC     ?DPS
        MOVX    @DPTR/*1*/,A
//  830         rc = SMPL_SUCCESS;
??SMPL_Ioctl_17:
        MOV     ?V0 + 0,#0x0
//  831       }
//  832       else
//  833       {
//  834         rc = SMPL_BAD_PARAM;
//  835       }
//  836       break;
//  837 
//  838     default:
//  839       rc = SMPL_BAD_PARAM;
//  840       break;
//  841   }
//  842 
//  843   return rc;
??SMPL_Ioctl_12:
        MOV     R1,?V0 + 0
??SMPL_Ioctl_1:
        MOV     DPL,?XSP + 0
        MOV     DPH,?XSP + 1
        ; Selecting DPTR 0 by inc-method (DPSEL=x)
        ANL     ?DPS,#0xfe
        LCALL   ?XSTACK_RESTORE_DPTRS_1
        LJMP    ?Subroutine1
//  844 }

        END
//  845 
//  846 /******************************************************************************
//  847  * @fn          ioctlPreInitAccessIsOK
//  848  *
//  849  * @brief       Is the request legal yet? Most requests are not legal before
//  850  *              SMPL_Init().
//  851  *
//  852  * input parameters
//  853  * @param   object   - The IOCTL target object
//  854  *
//  855  * output parameters
//  856  *
//  857  * @return   Returns non-zero if request should be honored for further
//  858  *           processing, otherwise returns 0. This function does not
//  859  *           determine of the object-action pair are valid. It only knows
//  860  *           about exceptions, i.e., those that are valid before the
//  861  *           SMPL_Init() call.
//  862  *
//  863  */
//  864 static uint8_t ioctlPreInitAccessIsOK(ioctlObject_t object)
//  865 {
//  866   uint8_t rc;
//  867 
//  868   /* Currently the only legal pre-init accesses are the address and
//  869    * the token objects.
//  870    */
//  871   switch (object)
//  872   {
//  873     case IOCTL_OBJ_ADDR:
//  874     case IOCTL_OBJ_TOKEN:
//  875       rc = 1;   /* legal */
//  876       break;
//  877 
//  878     default:
//  879       rc = 0;   /* not legal when init not done */
//  880       break;
//  881   }
//  882 
//  883   return rc;
//  884 }
// 
// 1 139 bytes in segment NEAR_CODE
//     1 byte  in segment XDATA_Z
// 
// 1 139 bytes of CODE  memory
//     1 byte  of XDATA memory
//
//Errors: none
//Warnings: none
